#! /usr/bin/perl

use English;

$::QT_MOC_PATH = find_moc ();

if (! -x $::QT_MOC_PATH) {
        print "Unable to find moc, or is not executable\n";
        if ( "MSWin32" ne "$OSNAME" ) {
                exit (1);
        }
}

chomp( $::QT_MOC_PATH );

exit main( @ARGV );

sub find_moc
{
        my $mocpath;

        if ($ENV{"QTDIR"} && -x "$ENV{\"QTDIR\"}/bin/moc") {
            return "$ENV{\"QTDIR\"}/bin/moc";
        }

    # here we need to do things differently for windows
    if ( "MSWin32" ne "$OSNAME" ) {
        $mocpath = `which moc 2>/dev/null`;
        if ($? == 0) {
            chomp $mocpath;
            return $mocpath;
        }

        $mocpath = `which moc-qt4 2>/dev/null`;
        if ($? == 0) {
            chomp $mocpath;
            return $mocpath;
        }
    } else {
        return "moc";
    }
}

sub main
{
    my @argv = @_;

    my @commandLineParameters = ( $::QT_MOC_PATH );

    my $filename = "";
    my $type = "";

    for ( my $i=0; $i<@argv; ++$i ) {
        if ( $argv[$i] =~ /style.h$/ ) {
            $type = "Style";
            $filename = $argv[$i];
        } elsif ( $argv[$i] =~ /model.h$/ ) {
            $type = "Model";
            $filename = $argv[$i];
        } else {
            push @commandLineParameters, $argv[$i];
        }
    }

    if ( $filename eq "" ) {
        system( @commandLineParameters );
    } else {
        push @commandLineParameters, "-f".$filename;

        if ( $type eq "Model" ) {
            runModelMoc( $filename, @commandLineParameters );
        } elsif ( $type eq "Style" ) {
            runStyleMoc( $filename, @commandLineParameters );
        }
    }

    return 0;
}

sub runStyleMoc
{
    my ($header, @arguments) = @_;

    my $commandLine = join( " ", @arguments );

    open( INF, "<$header" ) || die( "Could not open $header for reading : $!" );

    open( MOC, "|$commandLine" ) || die( "Could not run command $commandLine : $!" );

    while ( <INF> ) {
        chomp;
        my $line = $_;

        $line =~ s/\s*M_STYLE_ATTRIBUTE\s*\(\s*(\w+\:*\w*)\s*,\s*(\w+)\s*,\s*(\w+)\s*\)\s*/    Q_PROPERTY($1 $2 READ $2 WRITE set$3)/;
        $line =~ s/\s*M_STYLE_PTR_ATTRIBUTE\s*\(\s*(\w+\:*\w*\s*\*+)\s*,\s*(\w+)\s*,\s*(\w+)\s*\)\s*/    Q_PROPERTY(const $1 $2 READ $2 WRITE set$3)/;

        print MOC "$line\n";
    }

    close( MOC );

    close( INF );
}

sub runModelMoc
{
    my ($header, @arguments) = @_;

    my $commandLine = join( " ", @arguments );

    open( INF, "<$header" ) || die( "Could not open header file for reading : $!" );

    open( MOC, "|$commandLine" ) || die( "Could not run command $commandLine : $!" );

    while ( <INF> ) {
        chomp;
        my $line = $_;

        #matching for nested pairs of paranthesis', brackets or arrows
        my $naryoperators = qr/(?:(?>[*+-\/|&^]+))/;
        my $unaryoperators = qr/(?:(?>[!]+))/;
        my $pointers = qr/(?:(?>[*]+))/;
        my $parantheses = qr/\((?:(?>[^()]+)|(??{$parantheses}))*\)/;
        my $brackets = qr/\[(?:(?>[^[]]+)|(??{$brackets}))*\]/;
        my $arrows = qr/\<(?:(?>[^<>]+)|(??{$arrows}))*\>/;

        #arrows for template matching, brackets for array matching
        #paranthesis' for constructor matching
        my $typePattern = qr/\S+\s*$arrows\s*$pointers\s*$brackets |
                             \S+\s*$arrows\s*$paranthesis |
                             \S+\s*$arrows\s*$brackets |
                             \S+\s*$parantheses\s*$brackets |
                             \S+\s*$arrows\s*$pointers |
                             \S+\s*$pointers\s*$brackets |
                             \S+\s*$pointers |
                             \S+\s*$arrows |
                             \S+\s*$brackets |
                             \S+\s*$parantheses |
                             \S+\s*/x;

        $line =~ s/\s*M_MODEL_PROPERTY\s*\(\s*($typePattern)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(.+)\)\s*/    Q_PROPERTY($1 $2 READ $2 WRITE set$3)/;
        $line =~ s/\s*M_MODEL_PTR_PROPERTY\s*\(\s*($typePattern)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(.+)\)\s*/    Q_PROPERTY($1 $2 READ $2 WRITE set$3)/;
 
        print MOC "$line\n";
    }

    close( MOC );

    close( INF );
}
