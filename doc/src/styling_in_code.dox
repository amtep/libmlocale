/*! \page styling_in_code Styling in application code

\section styling_in_application_code Styling in application code

    \subsection architecture Architecture
        In MeeGo Touch Framework, the theme acts as a base for all the styling. If the theme is changed in
        runtime, the look and feel for the whole system can radically change. The following figure shows
        the basic building blocks of the MeeGo Touch style system. It also illustrates how the styling is
        integrated with the widgets.

        \image html widgets_style.png "Architecture of the MeeGo Touch styling system."

    \subsection mtheme MTheme
        All the style objects are used by the theme class. Theme class provides services to create a new style
        object and to release it. It reference counts all the style objects and provides a cache, which allows
        multiple widgets to share same style objects, therefore optimizing the speed and memory consumption of
        the system.

    \subsection mstylesheetparser MStyleSheetParser
        This class parses style sheets. It reads stylesheet files and converts them to data
        structure in memory. It also provides services to dump the whole data structure to disk and to read it
        back into memory. This is a huge optimization since the whole parsing process can be bypassed after the
        stylesheet has been processed once.

    \subsection mstylesheet MStyleSheet
        This class provides support for the actual cascading process when the style sheet is being processed
        runtime. It is responsible of populating the style classes and to handle all the style attributes in a
        type-safe manner.

    \subsection mstyle MStyle
        MStyle class is the actual container for all the style attributes. The attributes are stored as Qt
        properties and they can be therefore accessed easily and also they can be later on animated using
        property animators. MStyle is a base class for all the styles.

    \subsection style_classes MWidgetStyle, MButtonStyle, MLabelStyle
        These are MStyle-derived classes, providing a set of attributes for the same type of widget.
        Basically there is one style class per one stylable component in the MeeGo Touch Framework.

    \subsection mstylecontainer MStyleContainer
        MStyleContainer class groups multiple MStyle instances together. It provides services like
        indicating the mode of the stylable object to the style system; or later on, even animating attribute
        values between different styles. The style is always accessed through the container.

    \subsection creating_new_style_class Creating a new style class
        Creating a new style class is a pretty simple process. Basically what you do is just derive from the style
        class you want to inherit from and add the attributes you need. In this example, a new style is created for a
        custom widget, therefore we start by deriving the new style class from the MWidgetStyle class.

        An important thing to note is that when declaring a new style class, either the M_STYLE or M_STYLE_INTERNAL
        macro needs to be declared inside the class in the header file. Use M_STYLE when you inherit your style
        class from a style class which is defined outside of your library/application. Use M_STYLE_INTERNAL when
        you inherit from a style class which is defined in the same library/application you are working with. The
        macro will create a private data member to your class, which will later on during the process store the real
        attribute data of your style class.

        \code
        class MyWidgetStyle : public MWidgetStyle
        {
            Q_OBJECT
            M_STYLE(MyWidgetStyle)
        };
        \endcode

        \subsection defining_style_attributes Defining attributes for the style
            Attributes are declared by using the M_STYLE_ATTRIBUTE(type, name, Name) macro. This macro will
            generate accessor methods to your attribute and it will also create Q_PROPERTY definition for it,
            making your attribute exist in the Qt's meta object. M_STYLE_ATTRIBUTE has three parameters. The
            first one is the datatype of the attribute (int, qreal etc..) the other two concentrate on naming
            of the attribute and accessor methods.

            The name parameter of the macro will be converted to style sheet-attribute name so that every
            camelcase letter is converted to dash and lowercase letter (e.g. marginLeft becomes margin-left).

            Here is an example of our new style class, with two attributes defined:
            \code
            class MyWidgetStyle : public MWidgetStyle
            {
                Q_OBJECT
                M_STYLE(MyWidgetStyle)
                M_STYLE_ATTRIBUTE(int, borderWidth, BorderWidth)
                M_STYLE_ATTRIBUTE(QColor, borderColor, BorderColor)
            };
            \endcode

            Next step is to create a container class for the style objects of this type. Style container
            provides access to the actual style data and it also makes it possible to indicate to the style system
            that your stylable object has changed from one mode into another. Once again there are two macros:

            - M_STYLE_CONTAINER(style class name)
            - M_STYLE_CONTAINER_INTERNAL(style class name)

            If you used M_STYLE in the style class you must use M_STYLE_CONTAINER in the container class.
            If you used M_STYLE_INTERNAL in the style class you must use M_STYLE_CONTAINER_INTERNAL in the
            container class. This macro will automatically generate an accessor operator and reloading of the
            style data if the mode changes while the application is running. Note that the parameter of the macro
            needs to be the type of the style class you created above.

            The style container needs to be inherited from the corresponding container class, here's an example:
            \code
            MyWidgetStyleContainer : public MWidgetStyleContainer
            {
                M_STYLE_CONTAINER(MyWidgetStyle)
            };
            \endcode

            \image html style_macros.png "A diagram showing how macros are used in different libraries & executables."

        \subsection defining_modes_for_style Defining modes for the style
            If you decide to support modes in your style class, those can be defined with the M_STYLE_MODE macro.
            This macro will expand to a method, which will set the corresponding mode enabled. For example,
            M_STYLE_MODE(Indexing) will expand to a setModeIndexing() method, which can be called to start
            retrieving attribute values from that mode.

            Here's an example to add a few modes to the container
            \code
            MyWidgetStyleContainer : public MWidgetStyleContainer
            {
                M_STYLE_CONTAINER(MyWidgetStyleContainer)
                M_STYLE_MODE(Indexing)
                M_STYLE_MODE(SecondMode)
            };
            \endcode

            The new style class is now ready to be configured through the style sheets, see Styling with
            stylesheets for more details about that subject.

        \subsection accessing_style_attributes Accessing the style attributes
        MeeGo Touch provides a simple way to access the style attributes by providing a style instance for the
        stylable object. This class contains simple accessor methods which allows one to read the values of the
        attributes. The name of the accessor method is defined by the second parameter in the M_STYLE_ATTRIBUTE
        macro. See an example of accessing the style below.

        \code
        // assuming that widget is using MyWidgetStyle
        void MyWidgetView::doSomePainting(QPainter& painter)
        {
        .
        .
            // at same point, access style attributes
            int borderWidth = style()->borderWidth();
            painter.setPen(style()->borderColor());
        .
        .
        }
        \endcode

        \subsection runtime_style_changes Runtime style change for widgets
            When the style changes in runtime, the MWidgetView::applyStyle method will be called. It means
            that the attributes are reloaded with new values and they are ready to be used. This method is
            virtual and it can be overridden in the derived classes. See the example below.

            \code
            // in MyWidgetView.h
            class MyWidgetView : public MWidgetView
            {
                Q_OBJECT
                M_VIEW(MyWidgetModel, MyWidgetStyle)
            .
            .
            protected:
                // we want to do something when the style changes
                virtual void applyStyle();
            .
            .
            };
            
            // in MyWidgetView.cpp
            void MyWidgetView::applyStyle()
            {
                MWidgetView::applyStyle();
                
                // do whatever you want here...
                
            }
            \endcode

\section using_helper_tools Using helper tools
    There are two helper tools which make the creation of new style classes easier. These tools are mgen and
    mmoc. It is important to note that one doesn't have to use these tools, everything can be done without
    them. So if you decide to bypass the toolchain, it means that you have to write all the private classes and
    attribute accessor methods by yourself. Writing all of those files is a lot of work and you also get the
    responsibility to maintain all of those files. The toolchain does most of that stuff in compile time, so
    it is worth having a closer look at it.

    \subsection mgen mgen
        mgen generates private data classes and their content for all the styles. It also generates the
        constructor/destructor code to your style class among with all the needed necessary accessor methods.
        Everything is generated and compiled during the make process.

    \subsection mmoc mmoc
        mmoc is a pretty simple script. Because Qt's moc doesn't know how to expand macros there needs to be
        a way to expand the M_STYLE_ATTRIBUTE macros for it. The mmoc tool expands them to Qt's Moccer so that
        the Q_PROPERTY macro gets translated by the Qt Moc.
    
    \image html toolchain.png "Graph showing how mgen & mmoc are integrated into the build process."
    
    \subsection configuring_project_to_use_helper_tools Configuring your project to use helper tools
        In order to use the helper tools automatically, you need to add CONFIG += meegotouch to your .pro file. In
        addition, you must declare your model & style header files to be processed by adding them into the
        MODEL_HEADERS and STYLE_HEADERS. Note that your style & model headers must also exist in the common HEADER
        section. See the example .pro file below for how to do that.

        \code
        TEMPLATE = app
        TARGET = mywidget
        CONFIG += meegotouch # Requires libmeegotouch to be installed
        # Input
        SOURCES += main.cpp mywidget.cpp
        HEADERS += mywidget.h mywidgetstyle.h mywidgetmodel.h
        MODEL_HEADERS += mywidgetmodel.h
        STYLE_HEADERS += mywidgetstyle.h
        INCLUDEPATH += ../../src/include
        QMAKE_LIBDIR += ../../lib/
        \endcode


\section advanced_styling_in_app Advanced styling in application code

    \subsection parent_child_relationship_in_app Parent-child relationship in application
        Using parent-child relationship in styling needs nothing more than assigning a parent to the widget
        which needs to be styled. This can be achieved by calling QGraphicsItem::setParentItem method for the
        MWidgetController. After that the system is aware of the widgets parent, therefore being able to
        assign a proper style for it.

    \subsection mode_in_app Mode in application
        If the state of your stylable changes, you need to inform the styling system about it. This is done
        by calling the corresponding method in the MStyleContainer class. For example, if you have defined
        a mode 'Selected' to your style container class, you can call the setModeSelected() method to enable that
        kind of styling. The styling system uses the mode as a parameter in MTheme::style calls when it
        reloads the styles.

        Here's an example:
        \code
        // assume that this is defined in the MWidgetStyleContainer class
        M_STYLE_MODE(Selected)

        void MWidgetView::myEventHandler()
        {
            // Access style container and change the mode to selected
            style().setModeSelected();
        }
        \endcode

    \subsection named_objects_in_app Styling based on object naming
        By assigning an object name to the stylable object, the system identifies that the object will need
        unique styling. If this styling is defined in the style sheet, it will be automatically applied by
        the system. The object name is assigned to the stylable object by using the QObject::setObjectName method.
        The styling system uses the object name as a parameter in MTheme::style calls when it reloads the
        styles.

        Here's an example:
        \code
        // Assume that this is created earlier somewhere
        MButton* button;

        // this will assign a name for this widget, therefore enabling the named style for it
        button->setObjectName("mybutton");
        \endcode

    \subsection orientation_in_app Orientation in application
        Style changes & reloading during the device orientation change is a somewhat automatic process, at least
        for the widgets. Basically all the styles get reloaded automatically and the styling system uses the
        device orientation as a parameter in MTheme::style calls.

    \subsection type_in_app Type in application
        \todo Add documentation
*/
