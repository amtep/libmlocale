/*! \page prestart Prestartable application development How-To

Prestarting and lazy shutdown reduces the start-up time of an
application to zero: the application is able to show its GUI
immediately when requested. DUI supports prestarting and lazy shutdown
of application services, that is, applications that are started by
calling \c launch() or some other application-specific method in their
DBus interface.

Prestarted applications are started to a special \b prestarted \b
state by a daemon called \b Applifed. In that state they are running
in the background in their mainloop but not showing anything. If
terminated, Applifed re-prestarts them automatically.

Lazy shutdown allows an application to enter the \b prestarted \b
state instead of terminating, when closed by user. This makes the next
application start-up very fast. Automatically prestarted applications
can use lazy shutdown as well.


\section terminology Terminology

- \b Launch - user action that aims to starting an application
  (tapping the application icon, for instance).

- \b LazyShutdown and \b LazyShutdownMultiWindow - prestart modes in
  which an application process returns from the running state to the
  prestarted state when it is closed by the user or by the \c close()
  method in the DBus interface.

- \b Prestarted \b state - the state where an application waits for
  launching. In user point of view the application is not running, but
  it can be started up (switched to the running state) much faster
  than executing it from scratch. Attempts to show a window in this
  state are suppressed.

- \b Prestart \b mode - the property of an application that defines
  what happens to the application when it is closed. If not set,
  application does not support prestarting.

- \b Running \b state - the state where an application is running in
  the user point of view.

- \b TerminateOnClose and \b TerminateOnCloseMultiWindow- prestart
  modes in which an application process is terminated when the
  application is closed by the user or by the \c close() method in the
  DBus interface.


\section prestarting Prestarting an application

If an application supports prestarting, it must set the prestart mode
with \c DuiApplication::setPrestartMode(), regardless of the
commandline parameters and before using any other parts of the
prestarting API. A recommended place to do this is during or right
after instantiating the \c DuiApplication class.

Example:

\code
// example.cpp
// Minimal prestartable and lazy shutdownable application

#include <DuiApplication>
#include <DuiApplicationWindow>

int main(int argc, char ** argv)
{
    DuiApplication app(argc, argv);
    DuiApplication::setPrestartMode(Dui::LazyShutdown);

    DuiApplicationWindow window;
    window.show();

    return app.exec();
}
\endcode

Start the application to the prestarted state as follows.

\code
$ ./example -prestart &
\endcode

An application enters the prestarted state if it is started with the
\c -prestart commandline argument \b and it sets the prestart mode
before showing any windows. If either one of these conditions does not
hold, the application will enter to the running state.

The \c DuiApplicationWindow::show() method can be called even if the
application is in the prestarted state. The window will not become
visible to the user until the application is launched.

\c DuiApplication::isPrestarted() can be used to check if the
application is in the prestarted state.


\section launching Launching an application

If the \c launch() method in application's DBus interface is called
(because of user tapping the application icon, for instance) and the
application is in the prestarted state, the application is released
from the prestarted state and allowed to continue to the running
state.

For instance, launch the example application (see above) running on
the prestarted state as follows:

\code
$ dbus-send --dest=com.nokia.example --type="method_call" /org/maemo/dui com.nokia.DuiApplicationIf.launch
\endcode

The application can react to launching by connecting to the \c
DuiApplication::prestartReleased() signal, or by overriding
DuiApplication::releasePrestart() handler. The default handler shows
the active application window of a single-window application, if there
is such a thing.

For multiwindow applications the default handler does nothing. They
must explicitely release the application from the prestarted by
calling \c DuiApplication::setPrestarted(false) and show the window
after that.


\section lazyshutdown Returning to the prestarted state

An application returns from the running state to the prestarted state
if its prestarted mode is set to \c Dui::LazyShutdown or \c
Dui::LazyShutdownMultiWindow and its last window is closed.

The application can react to restoring the prestarted state by
connecting to the \c DuiApplication::prestartRestored() signal, or by
overriding the \c DuiApplication::restorePrestart() event handler.


\section automaticprestart Prestarting during boot and enabling lazy shutdown

In order to enable lazy shutdown of the application or make the
application prestartable during device boot, \c -prestart must be
added to the \b .service \b-file of the application:

\code
[D-BUS Service]
Name=com.nokia.example
Exec=/usr/bin/example -prestart
\endcode

Note: modifying the service file will not cause starting up the
application at boot, it only makes it possible.

If \b Applifed is used for prestarting applications at boot,
application-specific configuration files are located in \c
/etc/prestart. The files contain the name of the DBus service and the
prestarting priority. For instance (/etc/prestart/example.prestart):

\code
Service=com.nokia.example
Priority=1
\endcode

Boot time prestart configuration files are typically part of
platform-specific configurations, and \b not provided in application
packages.


\section killing Sudden deaths in the prestarted state

Applications in the prestarted state never interact with the user.
Neither should they take care of any critical tasks, because whether
or not the applications will be prestarted at all is up to the
configuration politics.

These facts make the applications in the prestarted state as number
one candidates for suspending and killing when the system resources
run low. Therefore, application developers must be aware that an
application in the prestarted state may be killed with KILL signal at
any time without any warning.


\section multiwindow Prestarting multiwindow applications

Multiwindow applications can be prestarted by using
LazyShutdownMultiWindow and TerminateOnCloseMultiWindow modes. The
difference to the single-window applications is that no window is
shown by default when the launch() method is called from the DBus
interface. The window should be shown by the code that handles the
DBus call, and the code should release the application from the
prestarted state before that. See the following example.

\code
void MultiWindowApplication::activateWindow(int index)
{
    // This is the real handler for DBus method activateWindow(int)

    index--;
    if (index >= 0 && index < NUM_WINDOWS)  {

        // Force release from prestart if in prestarted state.
        // This is important.
        if (isPrestarted()) {
            setPrestarted(false);
        }

        // Show the desired window
        m_window[index]->show();
        m_window[index]->activateWindow();
        m_window[index]->raise();

        // Show the page and activate it
        m_mainPage[index]->appear();
        m_mainPage[index]->activateWidgets();
    }
}
\endcode

A multiwindow application enters the prestarted state when all its
windows are closed. Cleaning up the closed windows can be done, for
instance, on the closeEvent handler of each window, or on restoring
the prestarted state when all windows are closed.


\section windowclose Controlling window closing on lazy shutdown

The default behavior on window close varies depending on the prestart
mode. On LazyShutdown and LazyShutdownMultiWindow windows are hidden
by default. On TerminateOnClose and TerminateOnCloseMultWindow windows
are really closed, just like when application has not been prestarted.

The default closing behavior can changed by overriding the closeEvent
handler of the window and using \c
DuiWindow::setCloseOnLazyShutdown. This is demonstrated in the
following example.

\code
#include <DuiApplication>
#include <DuiApplicationWindow>
#include <DuiApplicationPage>
#include <DuiComboBox>
#include <DuiDebug>
#include <QStringList>

class MyWindow : public DuiApplicationWindow
{
public:
   MyWindow();

protected:
    virtual void closeEvent(QCloseEvent *event);

private:
    DuiApplicationPage *page;
    DuiComboBox *comboBox;
};

MyWindow::MyWindow() 
{
    page=new DuiApplicationPage();
    page->setTitle("closeEvent example app");
    comboBox = new DuiComboBox();
    comboBox->setTitle("What should closeEvent do?");
    QStringList stringList;
    stringList << "Ignore closeEvent" << "Hide window (LazyShutdown)" << "Really close window";
    comboBox->addItems(stringList);
    page->setCentralWidget(comboBox);
    page->appear();
}

void MyWindow::closeEvent(QCloseEvent *event)
{
    switch (comboBox->currentIndex()) {
    case 0: 
        duiDebug("MyWindow") << "Ignore closeEvent(). Window is not closed.";
        event->ignore(); 
        break;
    case 1: 
        duiDebug("MyWindow") << "Lazy shutdown - hide window";
        setCloseOnLazyShutdown(false);
        event->accept(); 
        break;
    case 2:
    default: 
        duiDebug("MyWindow") << "Really close window";
        setCloseOnLazyShutdown(true);
        event->accept(); 
        break;
    }
}

int main(int argc, char **argv)
{
    DuiApplication app(argc, argv);
    DuiApplication::setPrestartMode(Dui::LazyShutdown);

    MyWindow *window = new MyWindow();
    window->show();
 
    return app.exec();
}
\endcode


\section example Example on using handlers

The following example presents a skeleton of a single window
application. If application is started with the \c -prestart
commandline argument, it connects the signal about restoring the
prestarted state to the slot that resets the page displayed on the
window. Note that showing and hiding the window does not require any
actions from the application developer in the single window
applications (see the default event handlers above).


\code

// More complex LazyShutdown example using signals.
// Using Dui::TerminateOnClose is just as simple, you'd just
// set that mode without handling any prestart
// restores or resets.

class MainPage: public DuiApplicationPage 
{
public slots:
    // Activate widgets here
    void activateWidgets();

    // Deactivate widgets and reset state
    void resetState();
};

int main(int argc, char ** argv)
{
    DuiApplication app(argc, argv);
    DuiApplication::setPrestartMode(Dui::LazyShutdown);

    DuiApplicationWindow window;
    window.show();

    MainPage mainPage;
    page.appear();

    // Check if app was run with -prestart
    if (app.isPrestarted()) {

        // Reset the state of the page shown on the window
        // when application returns from the running state
        // to the prestarted state
        app.connect(&app, SIGNAL(prestartRestored()), 
                    &mainPage, SLOT(resetState()));

        // Activate widgets when released from the prestarted state
        app.connect(&app, SIGNAL(prestartReleased()), 
                    &mainPage, SLOT(activateWidgets()));
    }

    return app.exec();
}
\endcode

\code

// Example of application that supports LazyShutdown -prestarting using virtual handlers 
// (cannot be compiled due to missing implementation for the example page):

class MyApplication : public DuiApplication
{
    Q_OBJECT

public:
    MyApplication(int argc, char ** argv);
    ~MyApplication();

    // Re-implementation
    virtual void releasePrestart();

    // Re-implementation
    virtual void restorePrestart();

private:

    // Main window
    DuiApplicationWindow * m_window;

    // DuiApplicationPage -derived page
    MainPage * m_page;
};

MyApplication::MyApplication(int argc, char ** argv) :
    DuiApplication(argc, argv)
{
    // Use the LazyShutdown mode
    setPrestartMode(Dui::LazyShutdown);

    m_window = new DuiApplicationWindow;
    m_window->show();

    m_page = new DuiApplicationPage;
    m_page->appear();

    // Run activateWidgets() here to setup things 
    // if app is NOT prestarted, otherwise it will be called
    // from the handler method.

    if (!isPrestarted()) {
        m_page->activateWidgets();
    }
}

void MyApplication::releasePrestart()
{
    // Your stuff here
    m_page->activateWidgets();

    // Call the default implementation to show the window.
    DuiApplication::releasePrestart();
}

void MyApplication::restorePrestart()
{
    // Your stuff here
    m_page->deactivateAndResetWidgets();

    // Call the default implementation to hide the window.
    DuiApplication::restorePrestart();
}

MyApplication::~MyApplication()
{
    delete m_window;
    delete m_page;
}

int main(int argc, char ** argv)
{
    MyApplication app(argc, argv);
    return app.exec();
}

\endcode

*/