/*! \page responsivewindow How to show a responsive window fast in a MeeGo Touch application

In some cases with heavy applications using the 
\subpage launcher "application launcher" will not give fast enough 
startup for the application. This being the case, the developer 
should consider implementing his application so that loading 
the GUI content of the application happens in several phases. The 
main point of this approach is to show the window with a minimal 
content as fast as possible when
the user starts the application, and after that update the application
page with the "real" content. This will make the startup experience
for the user more pleasant than waiting longer for the complete GUI content 
appearing to the screen. 

The purpose of this document is to give some ideas on how the 
developer can implement this feature in his application using 
means provided by Qt and how to avoid general problems with this
kind of approach. 

\section implementation Implementation basics

The basic implementation goes simply like this:

    \li Make the application use MBooster (see \ref launcher) 

    \li Show a temporary application page while loading/building up the actual content of the GUI on the background Note!!: This won't work without the application launcher and booster, because then the launch would be too slow.

In practice this can be achieved by creating the initial GUI content 
inside the constructor of the application's main page and defining 
a new public slot createFinalContent() which takes care of loading
the actual content of the application's GUI:

\code
MainPage::MainPage() 
{
    // Create the initial content in here

}

void MainPage::createFinalContent()
{

    // Create the actual content in here

}
\endcode

In application's main() one can now create the main page (with the
initial content inside it) and make it appear. After this we can
connect MApplicationWindow::displayEntered() to 
MainPage::createFinalContent(), which will take care of creating
the actual GUI of the application. This connection ensures that we 
will start loading the actual GUI content right after the initial content
has become visible on the display:


\code
M_EXPORT int main(int argc, char **argv)
{
    MApplication *app = MComponentCache::mApplication(argc, argv);
    MApplicationWindow *window = MComponentCache::mApplicationWindow();
    window->show();

    MainPage *mainPage = new MainPage();
    mainPage->appear();

    app->connect(mainPage, SIGNAL(displayEntered()), mainPage, SLOT(createFinalContent()));

    return app->exec();
}
\endcode

The final thing to remember is to disconnect the signal as a first 
step inside function MainPage::createFinalContent(). This 
ensures that the slot is called only once when starting the
application:

\code
void MainPage::createFinalContent()
{
    app->disconnect(this, SIGNAL(displayEntered()), this, SLOT(createFinalContent()));
    
    // Create the actual content here
}
\endcode

\section problems Possible problems

\subsection dlopen Minimize the time used for loading shared libraries

Shared libraries are loaded during the application start-up and 
that can take a lot of time. This time it's unfortunately affecting also the time
which is taken before any initial content can be shown.

To minimize this time it is important:

   \li Avoid any unnecessary linking of shared libraries to the application code. It is also recommended to consider to use <a href="http://www.gentoo.org/proj/en/qa/asneeded.xml"> --as-needed </a> parameter for the linker, to avoid these kind of problems.

   \li If possible, load the plugin-libraries after the initial content of the GUI is shown.

   \li If own shared libraries are used, the loading time of those should be optimized

Here is a few tips how to optimize loading time for your own shared
libraries:
   \li Don't do heavy initializations at the loading phase.
   \li All static constructors are executed when loading the library. Therefore, try to avoid the use of static constructors when implementing the library.
   \li Execute the initializations by calling separate method after the application window is shown.


\subsection responsive Keeping the GUI Responsive

When performing heavy operations in meegotouch applications it is 
important that the GUI of the application still remains responsive. 
This is a common issue in Qt applications and there are different 
ways to avoid it, depending on the situation. 

Loading the actual application content after
showing the initial GUI might be a time consuming operation. Usually 
the initial content itself does not contain interactive items which 
should be responsive, but still we should take into account, 
for example, that the user may want to close the application during the 
time the real content is being built up. 

As said, this a known issue in Qt application development in general and 
there is very good 
<a href="http://doc.trolltech.com/qq/qq27-responsive-guis.html">
documentation </a> available which presents a range of 
possible solutions to avoid freezing the GUI during long operations. 
In this documentation we have picked up two possible ways to 
go around this problem when implementing the GUI content loading in phases.

\subsubsection processevents Process events manually

The simplest solution to avoid freezing is to handle pending events from 
time to time manually while creating the content of the actual application
page. In practice this means calling MApplication::processEvents()
periodically whenever possible. 

For example, if you need to load and scale all the
images in the /root directory and show them in the actual application page
you keep GUI responsive as follows:

\code 
QDir dir("/root");
Q_FOREACH(QString file, dir.entryList(QStringList("*.jpg"))) {
    QImage scaledImg = QImage(file).scaledToWidth(864);
    policy->addItem(new MImageWidget(&scaledImg));
    QApplication::instance()->processEvents();
}
\endcode

There are still some problems in this approach. Events are handled
only after loading and scaling each individual image. In practice 
this means that GUI stays quite responsive as long as loading and
scaling one image is not taking too much time. When trying this example
with very large size image files, these operations can take even several
seconds per image. This means that if the user tries to close the application
during that time, the GUI responses to the close event only after a delay 
of several seconds. Therefore, in general the "processEvents()"-approach
should be used only in cases where several short operations are executed.

\subsubsection threadin Building the actual GUI in a separate thread

Another way to keep things responsive is to build the actual content inside
a separate thread. The main advantage of this approach is that the event
loop stays running virtually without any interrupts and thus the
GUI stays also responsive for user actions. The main disadvantage is that
this approach is a bit more complex to implement than simply calling processEvents() here and there.

Here is the same image loader example, but now with a worker class
inherited from QThread taking care of the heavy stuff:

\code
Worker::Worker(MApplicationWindow * window) :
    m_window(window)
{
    // Set parent so that the thread will be automatically deleted
    setParent(window);

    // Connect signal to start the thread
    connect(m_window, SIGNAL(displayEntered()), this, SLOT(start()));
}

QList<QImage> Worker::imageList() const
{
    return m_imageList;
}

void Worker::run() 
{
    // Disconnect from the triggering signal 
    QObject::disconnect(m_window, SIGNAL(displayEntered()), this, SLOT(start()));

    QDir dir("/root");  
    Q_FOREACH(QString file, dir.entryList(QStringList("*.jpg"))) {
        QImage scaledImg = QImage(file).scaledToWidth(864);
        m_imageList.append(scaledImg);
    }
}
\endcode

This signal connection is now needed in main():

\code
    app->connect(worker, SIGNAL(finished()), mainPage, SLOT(showContent()));
\endcode

Now, in main page's showContent() we can just use the already loaded and
scaled images from Worker class:

\code

void MainPage::showContent()
{
    QObject::disconnect(m_worker, SIGNAL(finished()), this, SLOT(appear()));

    MLinearLayoutPolicy *policy = new MLinearLayoutPolicy(m_layout, Qt::Vertical);

    Q_FOREACH(QImage image, m_worker->imageList()) {
        policy->addItem(new MImageWidget(&image, this));
    }

    m_layout->setLandscapePolicy(policy);
    m_layout->setPortraitPolicy(policy);
}

\endcode

Note that MImageWidget's cannot be created in the worker thread due to
thread safety issues. Qt would throw some warnings if tried.

\subsection rotation Rotation

As with the normal application GUI's, it is important to notice possible
screen orientation changes when the window is visible. In practice this
means that we have to define both landscape and portrait policies for the
initial GUI layout.

*/

